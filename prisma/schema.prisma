generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String           @id @default(cuid())
  email              String           @unique
  username           String?          @unique
  name               String?
  password           String
  role               UserRole         @default(FAN)
  image              String?
  verified           Boolean          @default(false)
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  hasVIPAccess       Boolean          @default(false)
  hasPremiumAccess   Boolean          @default(false)
  hasBackstageAccess Boolean          @default(false)
  hasFullAccess      Boolean          @default(false)
  canBuyTickets      Boolean          @default(true)
  accounts           Account[]
  apiTokens          ApiToken[]
  bandProfile        BandProfile?
  chatMessages       ChatMessage[]
  assignedMessages   ContactMessage[] @relation("AssignedMessages")
  respondedMessages  ContactMessage[] @relation("RespondedMessages")
  contactReplies     ContactReply[]   @relation("AdminReplies")
  sessions           Session[]
  tickets            Ticket[]
  user_blocks        user_blocks?

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verificationtokens")
}

model ApiToken {
  id          String    @id @default(cuid())
  name        String
  hashedToken String    @unique
  prefix      String
  userId      String
  permissions String[]
  expiresAt   DateTime?
  lastUsedAt  DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([hashedToken])
  @@map("api_tokens")
}

model Band {
  id             String       @id @default(cuid())
  name           String       @unique
  description    String?
  genre          String?
  foundedYear    Int?
  website        String?
  youtubeChannel String?
  spotifyUrl     String?
  instagramUrl   String?
  facebookUrl    String?
  image          String?
  verified       Boolean      @default(false)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  albums         Album[]
  bandProfile    BandProfile?
  events         Event[]
  gallery        Gallery[]

  @@map("bands")
}

model BandProfile {
  id         String   @id @default(cuid())
  userId     String   @unique
  bandId     String   @unique
  role       String?
  joinedDate DateTime @default(now())
  band       Band     @relation(fields: [bandId], references: [id])
  user       User     @relation(fields: [userId], references: [id])

  @@map("band_profiles")
}

model Event {
  id                  String      @id @default(cuid())
  title               String
  description         String?
  startDate           DateTime
  endDate             DateTime?
  venue               String
  city                String
  country             String
  maxCapacity         Int?
  basicTicketPrice    Decimal?
  standardTicketPrice Decimal?
  vipTicketPrice      Decimal?
  youtubeUrl          String?
  status              EventStatus @default(UPCOMING)
  createdAt           DateTime    @default(now())
  updatedAt           DateTime    @updatedAt
  bandId              String
  band                Band        @relation(fields: [bandId], references: [id])
  gallery             Gallery[]
  tickets             Ticket[]

  @@map("events")
}

model Ticket {
  id                    String       @id @default(cuid())
  ticketNumber          String       @unique
  type                  TicketType
  price                 Decimal
  status                TicketStatus @default(ACTIVE)
  qrCode                String?
  purchaseDate          DateTime     @default(now())
  allowsBasicAccess     Boolean      @default(false)
  allowsConcertAccess   Boolean      @default(true)
  allowsPremiumAccess   Boolean      @default(false)
  allowsVIPAccess       Boolean      @default(false)
  allowsBackstageAccess Boolean      @default(false)
  userId                String
  eventId               String
  payments              Payment[]
  event                 Event        @relation(fields: [eventId], references: [id])
  user                  User         @relation(fields: [userId], references: [id])

  @@map("tickets")
}

model AccessLevel {
  id              String   @id @default(cuid())
  name            String   @unique
  description     String?
  allowsConcert   Boolean  @default(false)
  allowsPremium   Boolean  @default(false)
  allowsVIP       Boolean  @default(false)
  allowsBackstage Boolean  @default(false)
  allowsAdmin     Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("access_levels")
}

model Album {
  id          String    @id @default(cuid())
  title       String
  releaseDate DateTime?
  coverImage  String?
  spotifyUrl  String?
  youtubeUrl  String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  bandId      String
  band        Band      @relation(fields: [bandId], references: [id])
  tracks      Track[]

  @@map("albums")
}

model Track {
  id          String  @id @default(cuid())
  title       String
  duration    Int?
  trackNumber Int
  youtubeUrl  String?
  spotifyUrl  String?
  albumId     String
  album       Album   @relation(fields: [albumId], references: [id])

  @@map("tracks")
}

model Gallery {
  id          String    @id @default(cuid())
  title       String?
  type        MediaType
  url         String
  description String?
  uploadedAt  DateTime  @default(now())
  eventId     String?
  bandId      String?
  band        Band?     @relation(fields: [bandId], references: [id])
  event       Event?    @relation(fields: [eventId], references: [id])

  @@map("gallery")
}

model ChatMessage {
  id      String   @id @default(cuid())
  content String
  room    ChatRoom
  sentAt  DateTime @default(now())
  userId  String
  user    User     @relation(fields: [userId], references: [id])

  @@map("chat_messages")
}

model PlatformStats {
  id           String   @id @default(cuid())
  date         DateTime @default(now())
  totalUsers   Int      @default(0)
  totalBands   Int      @default(0)
  totalEvents  Int      @default(0)
  totalTickets Int      @default(0)
  dailyRevenue Decimal  @default(0)

  @@map("platform_stats")
}

model Payment {
  id          String        @id @default(cuid())
  amount      Decimal
  currency    String        @default("EUR")
  status      PaymentStatus @default(PENDING)
  stripeId    String?
  description String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  ticketId    String
  ticket      Ticket        @relation(fields: [ticketId], references: [id])

  @@map("payments")
}

model ContactMessage {
  id            String          @id @default(cuid())
  name          String
  email         String
  subject       String
  message       String
  status        ContactStatus   @default(NEW)
  priority      MessagePriority @default(NORMAL)
  ipAddress     String?
  userAgent     String?
  isSpam        Boolean         @default(false)
  assignedToId  String?
  respondedAt   DateTime?
  respondedById String?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  closedAt      DateTime?
  gdprConsent   Boolean         @default(true)
  dataRetention DateTime
  assignedTo    User?           @relation("AssignedMessages", fields: [assignedToId], references: [id])
  respondedBy   User?           @relation("RespondedMessages", fields: [respondedById], references: [id])
  replies       ContactReply[]

  @@index([email])
  @@index([status])
  @@index([priority])
  @@index([assignedToId])
  @@index([createdAt])
  @@index([dataRetention])
  @@map("contact_messages")
}

model ContactReply {
  id          String         @id @default(cuid())
  messageId   String
  content     String
  isInternal  Boolean        @default(false)
  sentByEmail Boolean        @default(false)
  adminId     String
  createdAt   DateTime       @default(now())
  admin       User           @relation("AdminReplies", fields: [adminId], references: [id], onDelete: Cascade)
  message     ContactMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@index([adminId])
  @@index([createdAt])
  @@map("contact_replies")
}

model archived_tickets {
  id                    String       @id
  originalTicketId      String       @unique
  originalUserId        String
  originalUserEmail     String
  originalUserName      String?
  ticketNumber          String
  type                  TicketType
  price                 Decimal
  status                TicketStatus
  qrCode                String?
  purchaseDate          DateTime
  allowsBasicAccess     Boolean
  allowsConcertAccess   Boolean
  allowsPremiumAccess   Boolean
  allowsVIPAccess       Boolean
  allowsBackstageAccess Boolean
  eventId               String
  eventTitle            String
  eventDate             DateTime
  eventVenue            String
  archivedAt            DateTime     @default(now())
  archivedBy            String
  archiveReason         String
}

model user_blocks {
  id              String      @id
  userId          String      @unique
  reason          BlockReason
  description     String?
  blockedAt       DateTime    @default(now())
  blockedBy       String
  unblockedAt     DateTime?
  unblockedBy     String?
  isActive        Boolean     @default(true)
  unpaidTicketIds String[]
  totalDebt       Decimal?
  users           User        @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum UserRole {
  FAN
  BAND
  VIP_FAN
  BENEFIZ
  ADMIN
  MODERATOR
}

enum EventStatus {
  UPCOMING
  LIVE
  COMPLETED
  CANCELLED
}

enum TicketType {
  STANDARD
  VIP
  BACKSTAGE
  BAND_PASS
  ADMIN_PASS
}

enum TicketStatus {
  ACTIVE
  USED
  CANCELLED
  REFUNDED
}

enum MediaType {
  IMAGE
  VIDEO
  AUDIO
  DOCUMENT
}

enum ChatRoom {
  COMMUNITY
  BACKSTAGE
  VIP_LOUNGE
  PREMIUM
  SUPPORT
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum MessagePriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum ContactStatus {
  NEW
  READ
  IN_PROGRESS
  RESPONDED
  CLOSED
  SPAM
}

enum BlockReason {
  PAYMENT_FAILED
  SPAM_BEHAVIOR
  TOS_VIOLATION
  ADMIN_DECISION
  FRAUD_SUSPECTED
}
